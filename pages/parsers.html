<h1 id="oboe-js-vs-sax-vs-dom">Oboe.js vs SAX vs DOM</h1>
<p>Oboe.js aims to be fluid like a SAX parser but with the convenience of a DOM parser.</p>
<h2 id="choosing-a-parser">Choosing a parser</h2>
<p>DOM pros:</p>
<ul>
<li>It is very simple. Everybody knows how to use it.</li>
<li>The parsing is fast and native using <code>JSON.parse</code></li>
</ul>
<p>DOM cons:</p>
<ul>
<li>You can&#39;t do anything until you have the whole document.</li>
<li>If the connection drops while transferring you lose everything.</li>
<li>Perpetual documents are not possible.</li>
</ul>
<p>SAX pros:</p>
<ul>
<li>It has lean memory requirements. It can handle documents larger than the available RAM.</li>
</ul>
<p>SAX cons:</p>
<ul>
<li>The API is very low level. Simple tasks need quite a lot of programming.</li>
</ul>
<p>Oboe.js pros:</p>
<ul>
<li>Finding nodes is pattern-based. Unlike SAX, you don&#39;t have to maintain state on what you have already seen
in order to drill down into a JSON document.</li>
<li>Oboe&#39;s parser provides actual JS objects which can then be used much as you would with a DOM parser. In
comparison, with SAX you must programmatically infer objects from many callbacks.</li>
<li>Can be used to search the JSON while streaming is flowing.</li>
</ul>
<p>Oboe.js cons:</p>
<ul>
<li>Since it builds up the parsed result as actual JSON objects parsing a document takes about the same memory as a DOM parser.</li>
</ul>
<h2 id="code-comparison-sax">Code comparison: SAX</h2>
<p>We have JSON containing an array of people objects and we wish to extract the
name of the first person. Using SAX this is quite involved:</p>
<pre><code class="lang-js">function extractNameOfFirstPerson(){

   var parser = clarinet.parser(),

       // With a SAX parser it is the developer&#39;s responsibility 
       // to track where in the document the cursor currently is.
       // Several variables are required to maintain this state.        
       inPeopleArray = false,   
       inPersonObject = false,
       inNameAttribute = false,
       found = false;

   parser.onopenarray = function(){
      // For brevity we&#39;ll cheat by assuming there is only one
      // array in the document. In practice this would be overly
      // brittle.      
      inPeopleArray = true; 
   };

   parser.onclosearray = function(){
      inPeopleArray = false;
   };   

   parser.onopenobject = function(){
      inPersonObject = inPeopleArray; 
   };

   parser.oncloseobject = function(){
      inPersonObject = false;
   };   

   parser.onkey = function(key){
      inNameAttribute = (inPeopleObject &amp;&amp; key == &#39;name&#39;);
   };

   parser.onvalue = function(value){
      if( !found &amp;&amp; inNameAttribute ) {
         // finally!
         console.log(&#39;the name is&#39;, value); 
         found = true;
      }
   };      

   // return the parser to be hooked up to a stream
   return parser;   
}
</code></pre>
<h2 id="code-comparison-oboe-js">Code comparison: Oboe.js</h2>
<p>Oboe makes extracting the name very much easier, but reacts equally quickly
to the streamed input as the SAX example above:</p>
<pre><code class="lang-js">oboe(&#39;people.json&#39;)
   .node(&#39;[0].name&#39;, function(name){
      console.log(&#39;the name is&#39;, name);
   });
</code></pre>
